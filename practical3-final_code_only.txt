import tensorflow as tf

from tensorflow import keras

from keras.models import Sequential

from keras.layers import Dense,Conv2D,Dropout,Flatten,MaxPooling2D

import matplotlib.pyplot as plt

import numpy as np

#Loading and PreProcesssing the Image Data

mnist = tf.keras.datasets.mnist

(x_train,y_train),(x_test,y_test) = mnist.load_data()

input_shape=(28,28,1)

#Typecasting the training and testing datasets into float
x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test=x_test.reshape(x_test.shape[0],28,28,1)
x_train = x_train.astype('float32')
x_test = x_test.astype('float32')

x_train = x_train/255
x_test = x_test/255
print("Shape of Training:",x_train.shape)
print("Shape of Testing:",x_test.shape)

#Defining Models Architecture

model = Sequential()
model.add(Conv2D(28,kernel_size=(3,3),input_shape=input_shape))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Flatten())
model.add(Dense(200,activation='relu'))
model.add(Dropout(0.3))
model.add(Dense(10,activation='softmax'))

model.summary()

#Training the Model

model.compile(optimizer='adam',loss = 'sparse_categorical_crossentropy',metrics=['accuracy'])
history = model.fit(x_train,y_train,validation_split=0.1,epochs=10)

# Plot training & validation accuracy values
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Plot training & validation loss values
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

#Estimating Models Performance

test_loss,test_acc = model.evaluate(x_test,y_test)
print("Loss=%.3f" %test_loss)
print("Accuracy=%.3f" %test_acc)

import random
# Showing image at position[] from dataset:
index = random.randint(0,len(x_train)-1)
image = x_train[index]
plt.imshow(np.squeeze(image), cmap='gray')
plt.show()

# Predicting the class of image:
image=image.reshape(1, image. shape[0], image. shape[1], image. shape[2])
predict_model = model.predict([image])
print("Pedicted class: {}".format(np.argmax(predict_model)))





